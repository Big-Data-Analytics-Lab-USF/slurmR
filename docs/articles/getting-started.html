<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Getting Started with slurmR • slurmR</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha256-916EbMg70RQy9LHiGkXzG8hSg9EdNy97GazNG/aiY1w=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Getting Started with slurmR">
<meta property="og:description" content="">
<meta property="og:image" content="/logo.png">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">slurmR</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/getting-started.html">Getting Started with slurmR</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/USCbiostats/slurmR">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Getting Started with slurmR</h1>
                        <h4 class="author">George G. Vega Yon</h4>
            
            <h4 class="date">June 26, 2019 (last update Oct 31, 2019)</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/USCbiostats/slurmR/blob/master/vignettes/getting-started.Rmd"><code>vignettes/getting-started.Rmd</code></a></small>
      <div class="hidden name"><code>getting-started.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>Nowadays, high-performance-computing (HPC) clusters are commonly available tools for either in or out of cloud settings. <a href="https://slurm.schedmd.com/">Slurm Work Manager</a> (formerly <em>Simple Linux Utility for Resource Manager</em>) is a program written in C that is used to efficiently manage resources in HPC clusters. The slurmR R package provides tools for using R in HPC settings that work with Slurm. It provides wrappers and auxiliary functions that allow the user to seamlessly integrate their analysis pipeline with HPC, putting emphasis on providing the user with a family of functions similar to those that the parallel R package provides.</p>
<p>First, some important discussion points within the context of Slurm+R that users in general will find useful. Most of the points have to do with options available for Slurm, and in particular, with the <code>sbatch</code> command with is used to submit batch jobs to Slurm. Users who have used Slurm in the past may wish to skip this and continue reading the following section.</p>
<ul>
<li>
<p><strong>Node</strong> A single computer in the HPC: A lot of times jobs will be submitted to a single node. The simplest way of using R+Slurm is submitting a single job and requesting multiple CPUs to use, for example, <code><a href="https://rdrr.io/r/parallel/clusterApply.html">parallel::parLapply</a></code> or <code><a href="https://rdrr.io/r/parallel/mclapply.html">parallel::mclapply</a></code>. Usually users do not need to request an specific number of nodes to be used as Slurm will allocate the resources as needed.</p>
<p>A common mistake of R users is to specify the number of nodes and expect that their script will be parallelized. This won’t happen unless the user explicitly writes a parallel computing script.</p>
<p>The relevant flag for <code>sbatch</code> is <code>--nodes</code>.</p>
</li>
<li>
<p><strong>Partition</strong> A group of nodes in HPC. Generally large nodes may have multiple partitions, meaning that nodes may be grouped in various ways. For example, nodes belonging to a single group of users may be in a single partition, nodes dedicated to work with large data may be in another partition. Usually, partitions are associated with account privileges, so users may need to specify which account are they using when telling Slurm what partition they plan to use.</p>
<p>The relevant flag for <code>sbatch</code> is <code>--partition</code>.</p>
</li>
<li>
<p><strong>Account</strong> Accounts may be associated with partitions. Accounts can have privileges to use a partition or set of nodes. Often, users need to specify the account when submitting jobs to a particular partition.</p>
<p>The relevant flag for <code>sbatch</code> is <code>--account</code>.</p>
</li>
<li>
<p><strong>Task</strong> A step within a job. A particular job can have multiple tasks. tasks may span multiple nodes, so if the user wants to submit a multicore job, this option may not be the right one.</p>
<p>The relevant flag for <code>sbatch</code> is <code>--ntasks</code></p>
</li>
<li>
<p><strong>CPU</strong> generally this refers to core or thread (which may be different in systems supporting multithreaded cores). Users may want to specify how many CPUs they want to use for a task. And this is the relevant option when using things like OpenMP or functions that allow creating cluster objects in R (e.g. <code>makePSOCKcluster</code>, <code>makeForkCluster</code>).</p>
<p>The relevant option in <code>sbatch</code> is <code>--cpus-per-task</code>. More information regarding CPUs in Slurm can be found <a href="https://slurm.schedmd.com/cpu_management.html">here</a>.</p>
</li>
<li>
<p><strong>Job Array</strong> Slurm supports job arrays. A job array is in simple terms a job that is repeated multiple times by Slurm, this is, replicates a single job as requested per the user. In the case of R, when using this option, a single R script is spanned in multiple jobs, so the user can take advantage of this and parallelize jobs accross multiple nodes. Besides from the fact that jobs within a Job Array may be spanned accross multiple nodes, each job in that array has a unique ID that is available to the user via environment variables, in particular <code>SLURM_ARRAY_TASK_ID</code>.</p>
<p>Within R, and hence the Rscript submitted to Slurm, users can access this environment variable with <code><a href="https://rdrr.io/r/base/Sys.getenv.html">Sys.getenv("SLURM_ARRAY_TASK_ID")</a></code>. Some of the functionalities of <code>slurmR</code> rely on Job Arrays.</p>
<p>More information on Job Arrays can be found <a href="https://slurm.schedmd.com/job_array.html">here</a>. The relevant option for this in <code>sbatch</code> is <code>--array</code>.</p>
</li>
</ul>
<p>More information about Slurm can be found their official website <a href="https://slurm.schedmd.com/">here</a>. A tutorial about how to use Slurm with R can be found <a href="https://uscbiostats.github.io/slurmr-workshop">here</a>.</p>
</div>
<div id="submitting-jobs-via-sbatch" class="section level1">
<h1 class="hasAnchor">
<a href="#submitting-jobs-via-sbatch" class="anchor"></a>Submitting jobs via sbatch</h1>
<p>In general, users will submit jobs to Slurm using the <code>sbatch</code> command line function. The <code>sbatch</code> function’s main argument is the name (path) to a bash script that holds the instructions (and sometimes options) associated to the program. Here is an example of an bash file to be submitted to Slurm</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">#SBATCH --time=01:00:00</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#SBATCH --job-name="A long job"</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#SBATCH --mem=5GB</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#SBATCH --output=long-job.out</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="bu">cd</span> /path/where/to/start/the/job</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co"># This may vary per HPC system. At USC's hpc system</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co"># we use: source /usr/usc/R/default/setup.sh</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="ex">module</span> load R</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="ex">Rscript</span> --vanilla long-job-rscript.R</span></code></pre></div>
<p>This example bash file, wich we name “long-job-rscript.slurm”, has the following components:</p>
<ul>
<li><p><code>#!/bin/bash</code> The interpreter directive that is common to bash scripts. For more on this see <a href="https://askubuntu.com/questions/141928/what-is-the-difference-between-bin-sh-and-bin-bash">this thread on StackExchange</a>.</p></li>
<li><p>The <code>#SBATCH</code> lines specify options for scheduling the job. In order, these options are: Set a maximum time of 1 hour, name the job <code>A long job</code>, allocate 5GB of memory to the job, write all the output (including <code>Rscript</code>’s) to <code>long-job.out</code>.</p></li>
<li><p>The <code>cd</code> line changes the directory to some other place where the Rscript needs to be executed.</p></li>
<li><p>The <code>module</code> line loads R. There are various ways to do this, but it is a common requirement for the user to specify that it will be using R.</p></li>
<li><p>Finally, <code>Rscript</code> executes the R script named <code>long-job-rscript.R</code>.</p></li>
</ul>
<p>This batch script can be submitted to Slurm using the <code>sbatch</code> command line tool:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="ex">sbatch</span> long-job-rscript.slurm</span></code></pre></div>
<p>This is what happens under-the-hood in <code>slurmR</code> overall. The next section will discuss the ways in which <code>slurmR</code> enables out-of-the-box parallel computing using Slurm.</p>
</div>
<div id="implementation-of-the-slurmr-package" class="section level1">
<h1 class="hasAnchor">
<a href="#implementation-of-the-slurmr-package" class="anchor"></a>Implementation of the <code>slurmR</code> package</h1>
<div id="apply-family" class="section level2">
<h2 class="hasAnchor">
<a href="#apply-family" class="anchor"></a>*apply family</h2>
<p>Just like <code>rslurm</code>, <code>slurmR</code> has two levels of job distribution: first, Slurm Jobs (via the <code>Slurm_lapply</code> and <code>Slurm_Map</code> functions), and second, within each job via <code><a href="https://rdrr.io/r/parallel/mclapply.html">parallel::mclapply</a></code> and <code><a href="https://rdrr.io/r/parallel/mclapply.html">parallel::mcMap</a></code> (task forking).</p>
<p>In general, the function <code>Slurm_*</code> is implemented as follows:</p>
<ol style="list-style-type: decimal">
<li><p>List whatever R packages are loaded, including the path to the R package.</p></li>
<li><p>List all the objects passed via ellipsis (<code>...</code>), and, together with <code>X</code> and <code>FUN</code> or <code>f</code>, save them at <code>[job_path]/[job_name]/</code> as <code>[object-name].rds</code>.</p></li>
<li><p>Write out the corresponding R script and Slurm bash file, and save them as <code>[job_path]/[job_name]/00-rscript.r</code>, and <code>[job_path]/[job_name]/01-bash.sh</code> respectively.</p></li>
<li><p>If <code>submit = TRUE</code> (the default), the job will be submitted to the queue, which implies that <code>Slurm_lapply</code> will call <code><a href="../reference/sbatch.html">sbatch()</a></code>. Then return.</p></li>
<li><p>Once <code><a href="../reference/sbatch.html">sbatch()</a></code> is called, a Job Array will be submitted in which each R job will lunch up to <code>mc.cores</code> forked processes (2nd layer of palatalization)</p></li>
</ol>
<p>Users can collect their results using the function <code>Slurm_collect</code>. Furthermore The advantage of using this approach instead of using the <code>makeSlurmCluster</code> wrapper (which is discussed later) is that job-arrays can be re-submitted and, furthermore, the user can chose to not wait for the job to wait, and thus, quit the R session after submitting jobs to the queue.</p>
</div>
<div id="integration-with-the-parallel-package" class="section level2">
<h2 class="hasAnchor">
<a href="#integration-with-the-parallel-package" class="anchor"></a>Integration with the parallel package</h2>
<p>Another important component of <code>slurmR</code> is <code>makeSlurmCluster</code> function. This allow users creating multi-node PSOCKCluster class objects. The implementation of this function, wrapper of <code><a href="https://rdrr.io/r/parallel/makeCluster.html">parallel::makePSOCKcluster</a></code>, is very simple:</p>
<ol style="list-style-type: decimal">
<li><p>It submits a job to Slurm requesting the desired number of tasks. Each task will then return information regarding the node at which it is operating.</p></li>
<li><p>Once Slurm allocates the resources, the master R session (from which the job was submitted) will read in the node names returned by each task.</p></li>
<li><p>With the full list of nodenames in usage, <code>makeSlurmCluster</code> will pass the list of names to <code><a href="https://rdrr.io/r/parallel/makeCluster.html">parallel::makePSOCKcluster</a></code>, which ultimately creates the <code>cluster</code> class object.</p></li>
</ol>
<p>After creating the cluster object, the workflow is exactly the same as with the <code>parallel</code> package. Here is an example from the <code>makeSlurmCluster</code> manual</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Creating a cluster with 100 workers/offpring/child R sessions</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>cl &lt;-<span class="st"> </span><span class="kw"><a href="../reference/makeSlurmCluster.html">makeSlurmCluster</a></span>(<span class="dv">100</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co"># Computing the mean of a 100 random uniforms within each worker</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co"># for this we can use any of the function available in the parallel package.</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>ans &lt;-<span class="st"> </span><span class="kw">parSapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">200</span>, <span class="cf">function</span>(x) <span class="kw"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(<span class="dv">100</span>)))</span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co"># We simply call stopCluster as we would do with any other cluster</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co"># object</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="kw">stopCluster</span>(ans)</span></code></pre></div>
</div>
</div>
<div id="example-simulating-pi" class="section level1">
<h1 class="hasAnchor">
<a href="#example-simulating-pi" class="anchor"></a>Example simulating Pi</h1>
<p>We would like to implement a simulation algorithm to be run in a cluster. In this case, we have the very simple function we would like to parallelize:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>simpi &lt;-<span class="st"> </span><span class="cf">function</span>(n) {</span>
<span id="cb4-2"><a href="#cb4-2"></a>  points &lt;-<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span>(<span class="kw"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span>(n<span class="op">*</span><span class="dv">2</span>), <span class="dt">ncol=</span><span class="dv">2</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="kw"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/colSums.html">rowSums</a></span>(points<span class="op">^</span><span class="dv">2</span>) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">1</span>)<span class="op">*</span><span class="dv">4</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>}</span></code></pre></div>
<p>This simple function generates an estimate of Pi. This approximation is based on the following observation</p>
<p><span class="math display">\[
\mbox{Area} = \pi\times r^2 \implies \frac{Area}{r^2} = \pi
\]</span></p>
<p>Since we know what <span class="math inline">\(r\)</span> is, we just need to get an estimate of the Area to obtain an approximation of <span class="math inline">\(\pi\)</span>. A rather simple way of doing so is with Monte Carlo simulations, in particular, sampling points in a unit square. The proportion of points that fall within the unit circle, i.e. the proportion of points whose distance to the origin is smaller than the radius of the circle, has an expected value equal to the area of its circumscribed circle (for more details, check out the Wikipedia article about this topic <a href="https://en.wikipedia.org/wiki/Approximations_of_%CF%80#Summing_a_circle's_area">here</a>).</p>
<p>Using <code><a href="https://rdrr.io/r/parallel/mclapply.html">parallel::mclapply</a></code>, we could just type</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw"><a href="https://rdrr.io/r/base/Random.html">set.seed</a></span>(<span class="dv">12</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>ans &lt;-<span class="st"> </span>parallel<span class="op">::</span><span class="kw"><a href="https://rdrr.io/r/parallel/mclapply.html">mclapply</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">1e6</span>, <span class="dv">100</span>), simpi)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span>(ans))</span></code></pre></div>
<p>Which estimates pi using a single node(computer). However, we can simply exploit parallelization using <code>Slurm_lapply</code>, by writing</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span>(slurmR)</span></code></pre></div>
<pre><code>## Loading required package: parallel</code></pre>
<pre><code>## slurmR default options for `tmp_path` (used to store auxiliar files) set to:
##   /home/george/Documents/slurmR/vignettes
## You can change this and checkout other slurmR options using: ?opts_slurmR, or you could just type "opts_slurmR" on the terminal.</code></pre>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># Setting required parameters</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>opts_slurmR<span class="op">$</span><span class="kw">set_tmp_path</span>(<span class="kw"><a href="https://rdrr.io/r/base/tempfile.html">tempdir</a></span>())</span>
<span id="cb9-3"><a href="#cb9-3"></a>opts_slurmR<span class="op">$</span><span class="kw">set_job_name</span>(<span class="st">"test1"</span>)</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co"># Optional parameters are set via set_opts</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>opts_slurmR<span class="op">$</span><span class="kw">set_opts</span>(<span class="dt">partition=</span><span class="st">"conti"</span>, <span class="dt">account=</span><span class="st">"lc_dvc"</span>)</span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co"># We can look at the setup</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>opts_slurmR</span></code></pre></div>
<pre><code>## 
## Options for sbatch (Slurm workflow):
##   partition   : conti
##   account     : lc_dvc
##   job-name    : test1
## 
## Other options (R workflow):
##   tmp_path    : /tmp/RtmpTE5PW2
##   cmd         : sbatch
##   verbose     : FALSE
##   debug       : FALSE
## 
## To get and set options for Slurm jobs creation use (see ?opts_slurmR):
## 
## debug_off : function ()  
## debug_on : function ()  
## get_cmd : function ()  
## get_debug : function ()  
## get_job_name : function (check = TRUE)  
## get_opts_job : function (...)  
## get_opts_r : function (...)  
## get_tmp_path : function ()  
## get_verbose : function ()  
## set_job_name : function (path, check = TRUE, overwrite = TRUE)  
## set_opts : function (...)  
## set_tmp_path : function (path, recursive = TRUE, overwrite = FALSE)  
## verbose_off : function ()  
## verbose_on : function ()</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>job &lt;-<span class="st"> </span><span class="kw"><a href="../reference/Slurm_lapply.html">Slurm_lapply</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/rep.html">rep</a></span>(<span class="fl">1e6</span>, <span class="dv">100</span>), simpi, <span class="dt">njobs=</span><span class="dv">10</span>, <span class="dt">mc.cores=</span><span class="dv">10</span>, <span class="dt">plan =</span> <span class="st">"wait"</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a>ans &lt;-<span class="st"> </span><span class="kw"><a href="../reference/Slurm_collect.html">Slurm_collect</a></span>(job)</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw"><a href="https://rdrr.io/r/base/mean.html">mean</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/unlist.html">unlist</a></span>(ans))</span></code></pre></div>
</div>
<div id="common-options-to-pass-via-sbatch_opt" class="section level1">
<h1 class="hasAnchor">
<a href="#common-options-to-pass-via-sbatch_opt" class="anchor"></a>Common options to pass via <code>sbatch_opt</code>
</h1>
<p>Options to <code>sbatch</code> can be passed via <code>sbatch_opt</code> as a list. For example, the following</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw"><a href="https://rdrr.io/r/base/list.html">list</a></span>(</span>
<span id="cb12-2"><a href="#cb12-2"></a>  <span class="st">`</span><span class="dt">job-name</span><span class="st">`</span>      =<span class="st"> "my-fancy-slurm-job"</span>,</span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="st">`</span><span class="dt">mem-per-cpu</span><span class="st">`</span>   =<span class="st"> "4G"</span>,</span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="dt">time            =</span> <span class="st">"12:00:00"</span>,</span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="st">`</span><span class="dt">cpus-per-task</span><span class="st">`</span> =<span class="st"> </span><span class="dv">10</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>)</span></code></pre></div>
<p>Advises Slurm to allocate 4G of memory per task, set a maximum time limit of 12 hours, and specify that you will be using 10 CPUs.</p>
<p>A comprehensive list of options can be found <a href="https://slurm.schedmd.com/sbatch.html">here</a>.</p>
</div>
<div id="appendix" class="section level1">
<h1 class="hasAnchor">
<a href="#appendix" class="anchor"></a>Appendix</h1>
<p>Extract from the FAQs at the Slurm website:</p>
<blockquote>
<p><strong>30. Slurm documentation refers to CPUs, cores and threads. What exactly is considered a CPU?</strong> If your nodes are configured with hyperthreading, then a CPU is equivalent to a hyperthread. Otherwise a CPU is equivalent to a core. You can determine if your nodes have more than one thread per core using the command “scontrol show node” and looking at the values of “ThreadsPerCore”.</p>
<p><em>Note that even on systems with hyperthreading enabled, the resources will generally be allocated to jobs at the level of a core</em> (see NOTE below). Two different jobs will not share a core except through the use of a partition OverSubscribe configuration parameter. For example, a job requesting resources for three tasks on a node with ThreadsPerCore=2 will be allocated two full cores. Note that Slurm commands contain a multitude of options to control resource allocation with respect to base boards, sockets, cores and threads. — <a href="https://slurm.schedmd.com/faq.html#cpu_count">FAQ #30</a></p>
</blockquote>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">

        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#submitting-jobs-via-sbatch">Submitting jobs via sbatch</a></li>
      <li>
<a href="#implementation-of-the-slurmr-package">Implementation of the <code>slurmR</code> package</a><ul class="nav nav-pills nav-stacked">
<li><a href="#apply-family">*apply family</a></li>
      <li><a href="#integration-with-the-parallel-package">Integration with the parallel package</a></li>
      </ul>
</li>
      <li><a href="#example-simulating-pi">Example simulating Pi</a></li>
      <li><a href="#common-options-to-pass-via-sbatch_opt">Common options to pass via <code>sbatch_opt</code></a></li>
      <li><a href="#appendix">Appendix</a></li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by George Vega Yon, National Cancer Institute (NCI).</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
